#### 函数式编程 FP
函数式编程的思维方式： 对运算过程进行抽象

函数式编程的函数，不是程序中的函数，是指数学中的函数即映射关系



##### 函数式一等公民：

- 函数可以储存在变量中
- 函数可以作为参数
- 函数可以作为返回值

#####  高阶函数
##### 意义：

- 抽象可以帮我们屏蔽细节。只需要关注目标
- 高阶函数用来解决抽象通用的问题

##### 闭包：

调用一个函数内部的函数，并且访问到改函数的作用域内的成员，就会形成闭包

闭包的本质：函数在执行时，会被放在一个执行栈上，当函数执行完毕后，就会从执行栈中移除，但是栈上的作用域成员被外部引用不能释放，因此函数内部依然可以访问外部函数成员

##### 纯函数：
相同的输入，始终要得到相同的输出，是描述输入与输出关系的。

lodash是一个纯函数的库

slice是一个纯函数

```
arr.slice(0, 3)  //结果一样，不修改原数组
arr.slice(0, 3)
arr.slice(0, 3)
```
优势：

因为输入不变，输出不变，所以可缓存第一次的值


副作用：如果函数依赖于外界状态，那么就会导致函数不纯

##### 柯里化：

将函数需要多个参数的形式，改为先传递一部分参数，返回新的函数，接收剩余的参数

```
lodash中的柯里化

function getNum(a,b,c) {
    return a +b +c
}
const curry = _.curry(getNum)
console.log(curry(1,2,3))
console.log(curry(1,2)(3))
console.log(curry(1)(2)(3))
```

```
柯里化模拟实现
function curry(func) {
    return function curryFn(...args) {
        if(args.length < func.length) {
            return function() {
                return curryfn(...ags.concat(Array.from(arguments)))
            }
        }
        return func(...args)
    }
}
let c = curry(function(a, b,c) {
    return a + b + c
})
c(1)(2)(3)
```
##### 函数组合
如果一个函数需要多个函数处理擦四能得到最终值，这个时候可以把中间过程的函数合并成为一个函数

类似数据的管道

函数组合默认从右向左执行


```
组合函数模拟 _.flowRight
function compose(...args) {
    return function(value) {
        return arg.reverse().reduce((acc,fn) => {
            return fn(acc)
        }, value)
    }
}
let c = compose(fn1,fn2,fn3)
c([1,2,3])
```

##### lodash fp:
fp先函数，再数据。可以解决map带来的小问题

##### Point free：
定义：我们可以把数据处理的过程定义成与数据无关的合成运算，不需要用到代表数据的那个参数，只要把简单的运算合成到一步，在使用这种模式之前，需要定义一些基本的运算函数。
- 不需要指明处理的数据
- 只需要合成运算过程
- 定义一些辅助函数

##### 函子：
什么是functor?
- 容器：包含值和值的变形关系,变形关系就是函数
- 函子：是一个特殊的容器，通过一个普通的对象来实现，该对象具有map方法


```
//基本的函子
class Container{
    static of(value) {
        return new Container(value)
    }
    constructor(value) {
        this._value = value
    }
    map(fn) {
        return Container.of(fn(this._value))
    }
}
```
#####  mayBe函子
 
```
class MayBe{
    static of(value) {
        return new MayBe(value)
    }
    constructor(value) {
        this._value = value
    }
    map(fn) {
        return this.isNoting() ?
        MayBe.of(null) :
        MayBe.of(fn(this._value))
    }
    isNoting() {
        return this.value === null || this.value === undefined
    }
}
```
##### task函子


```
function readFile(file){
    return task(resolver => {
        fs.readFile(filename, 'utf-8', (err, data) => {
            if(err) resolver.reject(err)
            resolver.resolve(data)
        })
    })
}
readFile('1.txt').run().listen({
    onRejected: err => {
        
    },
    onResolved: value => {
        
    }
})
```

#### 性能优化
##### 内存管理：
- 内存：由可读写单元组成，表示一片可操作空间
- 管理：人为的去操作一片空间的申请，读写和使用
- 内存管理：开发者主动申请空间，使用及释放空间

##### 垃圾回收：
- js的内存管理是自动的
- 对象不再被引用时就是垃圾
- 对象不能从根上访问到时也是垃圾

##### js中的可达对象：
- 可以访问到的对象就是可达对象
- 可达的标准就是从根出发是否能够被找到
- js的根可以理解为是全局对象

##### GC算法：
- 是一种机制，垃圾回收器完成具体的工作
- 工作内容就是查找释放空间，回收空间
- 算法就是工作时查找和回收所遵循的规则

常用GC算法：
- 引用计数
- 标记清除
- 标记整理
- 分代回收

1、引用计数：

- 核心思想：设置引用数，判断当前引用数是否为0
- 引用关系改变时，修改引用数字
- 引用数字为0立即回收

优点：
- 发现垃圾立即回收
- 最大限度减少程序暂停

缺点：
- 无法回收循环引用的对象
- 时间开销大

2、标记清除
- 核心思想：分标记和清除两个阶段，标记可达对象
- 遍历所有对象标记活动对象
- 遍历所有对象清除没有标记的对象
- 回收相应的空间

缺点：

空间碎片化，当回收的垃圾对象，在地址上是不连续的，那么当新开辟空间时，就会造成无法开辟一段连续的空间问题。

3、标记整理法

- 标记清除的增强版
- 标记是相同的
- 清除会先整理，产生连续空间

#### V8引擎
内存设限1.5G 32位是800M

##### V8的垃圾回收策略：
- 采用分代回收
- 内存分为新生代，老生代
- 针对不同对象，采用不同算法

新生代：
- 32M | 16M
- 指的是存活时间较短的对象
- 过程采用复制算法+标记整理
- 新生代内存区域一分为二
- 使用空间form + 空闲空间to
- 活动对象存储于from空间
- 标记整理后，将对象拷贝至to空间
- form与to交换空间完成释放

细节：
- 拷贝出现晋升
- 晋升就是将新生代移动到老生代
- 一轮GC还存活的新生代需要晋升
- to空间的使用率超过25%

老生代：
- 1.4G | 700M
- 存活时间长的对象，全局，闭包等
- 主要采用标记清除，标记整理，增量标记
- 标记清除法完成垃圾空间的回收
- 采用标记整理进行空间优化（新生代往老生代移动时，发现空间不足时，就会进行标记整理）
- 采用增量标记进行效率优化

GC的目的：是为了实现内存空间的良性循环
##### 内存问题的外在表现：

- 页面出现延迟加载或经常性暂停 频繁的垃圾回收
- 持续的糟糕性能 内存膨胀
- 页面随时间越来越差 内存泄漏

问题标准：

- 内存泄漏：内存使用持续升高
- 内存膨胀：在多数设备上都存在性能问题，程序本身有问题
- 频繁的垃圾回收： 内存变化图分析

##### 监控内存的几种方式：
- 浏览器任务管理器
- timeline时序图记录
- 堆快照查找分离DOM
- 判断是否存在频繁的垃圾回收

##### 什么是分离DOM：看不到，但是存于内存
- 界面元素存活在dom树上
- 垃圾对象时的dom节点 脱离且没有引用
- 分离状态的dom节点 脱离但是被引用

##### 确定频繁的垃圾回收：
- timeline频繁升降
- 任务管理器中数据频繁增加和减小

##### 其他优化的总结：
- 在原型上添加方法比在实例上添加性功能好
- 传入函数比直接将函数写在参数上要好
- 缓存全局变量会更好一些
- for循环中，将获取的长度缓存下来
- foreach > for >for...in
- 利用文档对象，减少重回与回流，createDocumentFragment()

