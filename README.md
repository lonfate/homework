### 答案与说明：
#### 第一题：
答案：10

原因:

&emsp;&emsp;在这里i变量是一个全局变量，处于全局作用域之下，那么函数中所打印的i变量，就是循环执行完之后的数值，所以是10


解决办法：


1、用闭包的方式，保存每次的i变量


2、将var改为let，let具有自己的块级作用域

#### 第二题：
答案：会报错


原因：let没有变量提升的作用，所以不能先读取，再定义。而在if块级作用域中，明显是先读取，再定义，所以会报错

#### 第三题：
答案：


var arr = [12,34,32,89,4]
const min = Math.min(...arr)
原因：


Math.min() 接受的参数是一组数值，那么就需要将数组利用扩展符将其转换为一组数值

#### 第四题：
答案：


- var没有块的概念，对于块级作用域来说，可以跨块访问。
    
    
- let 只能在块级作用域内访问，不可以跨块访问，也不能重复定义
    
    
- const 定义的变量，不能够修改（等号右边的值，不能够重新赋予，可以修改定义的对象里面的值）

#### 第五题：
答案：20


原因：一般来说，setTimeout中this指向window，但是箭头函数不会改变this的指向，所以this指向调用fn的obj

#### 第六题：
答案：


1. Symbol具有独一无二性，可以用于定义“私有”属性
1. 对象定义了Symbol.iterator就可以利用for...of循环

#### 第七题：
答案：

1. 浅拷贝，只是复制了对象的指针，没有复制对象本身，修改一个对象可能会影响另外一个
1. 深拷贝，复制了引用对象本身，修改对象不会影响到被复制的对象

#### 第八题：
答案：

1. EventLoop是一种程序执行模式-事件循环。js运行时，会优先执行同步任务，遇到异步任务就会将其压入一个调用栈，等待同步任务结束后，去调用栈中依次调用执行异步任务，其中微任务优先于宏任务
1. 微任务：Process.nextTick（Node独有）、Promise、MutationObserver
1. 宏任务setTimeout、setInterval、setImmediate、I/O、UI渲染

#### 第九题：
答案：

```
async function task() {
    var a,b,c
    await setTimeout(() => {
        a = 'hello '
    },10)
    await setTimeout(() => {
        b = 'lagou '
    },10)
    await setTimeout(() => {
        c = 'I love U'
        console.log(a + b + c)
    },10)
}
task()
```


#### 第十题：
答案：
1. TypeScript是js的一个超集
2. TS解决了JS弱类型这个特点带来的问题：
    1. 代码在运行时，才能发现错误
    2. 代码执行结果与预期不符，例如类型转换带来的困扰
 
#### 第十一题：
答案：


优点：

1. 对数据有明确的类型说明
1. 静态检查及时发现问题
1. 加强了class的相关语法
1. 避免了隐式类型转换带来的问题
1. 更有利于团队合作的代码维护


缺点：


1. 在浏览器端，需要编译后才能执行
1. 小型项目引入TS会增加额外的成本
1. 对少部分的库，还有兼容问题